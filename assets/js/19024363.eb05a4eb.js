(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2750],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),y=p(n),d=o,f=y["".concat(l,".").concat(d)]||y[d]||c[d]||a;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=y;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}y.displayName="MDXCreateElement"},8647:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l},default:function(){return u}});var r=n(2122),o=n(9756),a=(n(7294),n(3905)),i={id:"type-safety",title:"Type-Safety",sidebar_label:"Type Safety"},s={unversionedId:"essentials/type-safety",id:"essentials/type-safety",isDocsHomePage:!1,title:"Type-Safety",description:"If you are using TypeScript, and you wish to get a better integration for GraphQL and TypeScript while writing your API and resolvers, we have a few tools that might make it simple for you.",source:"@site/docs/essentials/type-safety.md",sourceDirName:"essentials",slug:"/essentials/type-safety",permalink:"/docs/essentials/type-safety",editUrl:"https://github.com/Urigo/graphql-modules/edit/master/website/docs/essentials/type-safety.md",version:"current",sidebar_label:"Type Safety",frontMatter:{id:"type-safety",title:"Type-Safety",sidebar_label:"Type Safety"},sidebar:"docs",previous:{title:"Context",permalink:"/docs/essentials/context"},next:{title:"Testing",permalink:"/docs/essentials/testing"}},l=[{value:"Using Context type",id:"using-context-type",children:[]},{value:"Shaping Context type",id:"shaping-context-type",children:[]},{value:"Strict Resolvers Types",id:"strict-resolvers-types",children:[]}],p={toc:l};function u(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"If you are using TypeScript, and you wish to get a better integration for GraphQL and TypeScript while writing your API and resolvers, we have a few tools that might make it simple for you."),(0,a.kt)("h2",{id:"using-context-type"},"Using Context type"),(0,a.kt)("p",null,"While writing you resolvers, if you wish to type your ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," argument based on your actual ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," shape, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLModules.Context"),". It a global interface expose for you by GraphQL-Modules and allow you to easily type your ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," object."),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLModules.Context")," is simple and because it's a globally available type, you just use it, there's no need to import it from ",(0,a.kt)("inlineCode",{parentName:"p"},"graphql-modules")," package."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const resolvers = {\n  Query: {\n    myQuery(root, args, context: GraphQLModules.Context, info) {\n      // ...\n    },\n  },\n};\n")),(0,a.kt)("h2",{id:"shaping-context-type"},"Shaping Context type"),(0,a.kt)("p",null,"GraphQL Modules expose a global namespace called ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLModules"),", so there's no need to pass the same signature over and over again as part of generic types of different APIs."),(0,a.kt)("p",null,"Context is global and shared across modules and application which means you can define it once and it applies automatically everywhere."),(0,a.kt)("p",null,"Use and extend ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLModules.GlobalContext")," like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"declare global {\n  namespace GraphQLModules {\n    interface GlobalContext {\n      request: any;\n    }\n  }\n}\n")),(0,a.kt)("p",null,"Now every piece of GraphQL Modules understands the context and you gain much stronger type-safety. If you are using ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLModules.Context")," in your resolvers, it will get updated automatically."),(0,a.kt)("h2",{id:"strict-resolvers-types"},"Strict Resolvers Types"),(0,a.kt)("p",null,"If you wish to have even more control over you implementation, you can use GraphQL-Code-Generator to generate resolvers signature types per each module you write. This is useful because this way you can find issues during development/build time, and get complete type-safety and auto-complete in your IDE."),(0,a.kt)("p",null,"We created a special GraphQL-Code-Generator ",(0,a.kt)("inlineCode",{parentName:"p"},"preset")," for that purpose. It generates a complete, unified, type signature for your schema, and sub-files per each module, containing only the GraphQL types declared/extended in your specific module."),(0,a.kt)("p",null,"To get started, ",(0,a.kt)("a",{parentName:"p",href:"https://graphql-code-generator.com/docs/presets/graphql-modules"},"follow the instructions in ",(0,a.kt)("inlineCode",{parentName:"a"},"graphql-code-generator.com")," website"),"."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"TIP: To get the most out of your GraphQL-Code-Generator integration, please ",(0,a.kt)("a",{parentName:"p",href:"https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen"},"refer to this blog post"),". You can use your own model types, automatically type ",(0,a.kt)("inlineCode",{parentName:"p"},"parent")," value of your resolvers, have a fine-grain control of the output and much more!")))}u.isMDXComponent=!0}}]);