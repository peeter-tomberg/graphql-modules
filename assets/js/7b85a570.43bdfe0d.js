(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[625],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return y}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),s=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=s(n),y=r,f=d["".concat(l,".").concat(y)]||d[y]||u[y]||a;return n?o.createElement(f,c(c({ref:t},p),{},{components:n})):o.createElement(f,c({ref:t},p))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,c=new Array(a);c[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,c[1]=i;for(var s=2;s<a;s++)c[s]=n[s];return o.createElement.apply(null,c)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7767:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return c},metadata:function(){return i},toc:function(){return l},default:function(){return p}});var o=n(2122),r=n(9756),a=(n(7294),n(3905)),c={id:"lifecycles",title:"Lifecycles"},i={unversionedId:"advanced/lifecycles",id:"advanced/lifecycles",isDocsHomePage:!1,title:"Lifecycles",description:"Lifecycle hooks",source:"@site/docs/advanced/lifecycles.md",sourceDirName:"advanced",slug:"/advanced/lifecycles",permalink:"/docs/advanced/lifecycles",editUrl:"https://github.com/Urigo/graphql-modules/edit/master/website/docs/advanced/lifecycles.md",version:"current",frontMatter:{id:"lifecycles",title:"Lifecycles"},sidebar:"docs",previous:{title:"Execution Context",permalink:"/docs/advanced/execution-context"},next:{title:"Solve N+1 Using DataLoader",permalink:"/docs/recipes/dataloader"}},l=[{value:"Lifecycle hooks",id:"lifecycle-hooks",children:[]},{value:"Manual control of operation cycle",id:"manual-control-of-operation-cycle",children:[{value:"autoDestroy",id:"autodestroy",children:[]}]}],s={toc:l};function p(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,o.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"lifecycle-hooks"},"Lifecycle hooks"),(0,a.kt)("p",null,"There are two life cycle hooks in GraphQL Modules, one represents an incoming request and the other is called when the execution is done. Hooks are only available in Operation scoped Injector."),(0,a.kt)("p",null,"Every Operation scoped service is created for each incoing GraphQL operation, which means you can use the constructor as the initial hook."),(0,a.kt)("p",null,"After Operation is resolved and the context about to be destroyed, GraphQL Modules call the ",(0,a.kt)("inlineCode",{parentName:"p"},"onDestroy")," method on all operation-scoped services."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Injectable, Scope, OnDestroy } from 'graphql-modules';\n\n@Injectable({\n  scope: Scope.Operation,\n})\nexport class Data implements OnDestroy {\n  constructor() {\n    // incoming operation, here you can do your setup and preparation\n  }\n\n  onDestroy() {\n    // Operation is resolved\n    // Execution context is about to be disposed\n  }\n}\n")),(0,a.kt)("h2",{id:"manual-control-of-operation-cycle"},"Manual control of operation cycle"),(0,a.kt)("p",null,"As you know, GraphQL operation represents an incoming request with GraphQL query and variables meaning it ends when GraphQL API resolves data and sends back the response. An operation is created when GraphQL execution starts (",(0,a.kt)("inlineCode",{parentName:"p"},"execute")," function call). With operation comes Operation-scoped Dependency Injection."),(0,a.kt)("p",null,"In some cases you wish to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"access operation-scoped services before the execution phase happens"),(0,a.kt)("li",{parentName:"ul"},"destroy a session and operation-scoped injectors some time after execution phase")),(0,a.kt)("p",null,"This is why ",(0,a.kt)("inlineCode",{parentName:"p"},"OperationController")," exists - it allows to fully control the life of the operation-scoped injectors."),(0,a.kt)("p",null,"Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"@Injectable({ scope: Scope.Operation })\nclass Status {\n  enabled = true;\n  enable() {\n    this.enabled = true;\n  }\n  disable() {\n    this.enabled = false;\n  }\n}\n\nconst mod = createModule({\n  id: 'status',\n  providers: [Status]\n})\n\nconst app = createApplication({\n  modules: [mod],\n  providers: [Data],\n});\n\nserver.use('/graphq', (req, res) => {\n  const controller = app.createOperationController({\n    /*\n      It's important to pass a correct context value here.\n      This value represents a context object available in Dependency Injection.\n      Keep on mind, it doesn't have to be the same context object as your resolvers get.\n    */\n    context: {},\n  });\n\n  const status = controller.injector.get(Status);\n\n  if (process.env.NODE_ENV === 'production') {\n    status.disable();\n  }\n\n  // < graphql execution here >\n\n  controller.destroy();\n});\n")),(0,a.kt)("h3",{id:"autodestroy"},"autoDestroy"),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"OperationController")," means you're in charge of the operation flow and you need to destroy the session manually by default. "),(0,a.kt)("p",null,"To improve the developer experience, we decided to introduce ",(0,a.kt)("inlineCode",{parentName:"p"},"autoDestroy")," flag that automatically destroys the session right after GraphQL execution phase ends, exactly like without an OperationController."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const controller = app.createOperationController({\n  context: {},\n  autoDestroy: true,\n});\n\n// no need to call `controller.destroy()` now\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Keep on mind that using ",(0,a.kt)("inlineCode",{parentName:"p"},"autoDestroy")," means the controller completes its job immediately after execution phase and everything is cleaned up.")))}p.isMDXComponent=!0}}]);