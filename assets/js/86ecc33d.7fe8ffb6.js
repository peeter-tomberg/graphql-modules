(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8186],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return d},kt:function(){return c}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,g=m["".concat(s,".").concat(c)]||m[c]||u[c]||a;return n?o.createElement(g,i(i({ref:t},d),{},{components:n})):o.createElement(g,i({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<a;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8448:function(e,t,n){"use strict";var o=n(7294);t.Z=function(e){var t=e.children,n=e.hidden,r=e.className;return o.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},2168:function(e,t,n){"use strict";n.d(t,{Z:function(){return d}});var o=n(7294),r=n(50),a=n(6010),i="tabItem_1uMI",l="tabItemActive_2DSg";var s=37,p=39;var d=function(e){var t=e.lazy,n=e.block,d=e.defaultValue,u=e.values,m=e.groupId,c=e.className,g=(0,r.Z)(),h=g.tabGroupChoices,k=g.setTabGroupChoices,y=(0,o.useState)(d),f=y[0],v=y[1],N=o.Children.toArray(e.children),b=[];if(null!=m){var w=h[m];null!=w&&w!==f&&u.some((function(e){return e.value===w}))&&v(w)}var T=function(e){var t=e.currentTarget,n=b.indexOf(t),o=u[n].value;v(o),null!=m&&(k(m,o),setTimeout((function(){var e,n,o,r,a,i,s,p;(e=t.getBoundingClientRect(),n=e.top,o=e.left,r=e.bottom,a=e.right,i=window,s=i.innerHeight,p=i.innerWidth,n>=0&&a<=p&&r<=s&&o>=0)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(l),setTimeout((function(){return t.classList.remove(l)}),2e3))}),150))},x=function(e){var t,n;switch(e.keyCode){case p:var o=b.indexOf(e.target)+1;n=b[o]||b[0];break;case s:var r=b.indexOf(e.target)-1;n=b[r]||b[b.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},c)},u.map((function(e){var t=e.value,n=e.label;return o.createElement("li",{role:"tab",tabIndex:f===t?0:-1,"aria-selected":f===t,className:(0,a.Z)("tabs__item",i,{"tabs__item--active":f===t}),key:t,ref:function(e){return b.push(e)},onKeyDown:x,onFocus:T,onClick:T},n)}))),t?(0,o.cloneElement)(N.filter((function(e){return e.props.value===f}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},N.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==f})}))))}},2713:function(e,t,n){"use strict";var o=(0,n(7294).createContext)(void 0);t.Z=o},50:function(e,t,n){"use strict";var o=n(7294),r=n(2713);t.Z=function(){var e=(0,o.useContext)(r.Z);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},2982:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return m}});var o=n(2122),r=n(9756),a=(n(7294),n(3905)),i=n(2168),l=n(8448),s={id:"testing",title:"Testing",sidebar_label:"Testing"},p={unversionedId:"essentials/testing",id:"essentials/testing",isDocsHomePage:!1,title:"Testing",description:"GraphQL Modules provides a set of utilities for testing your modules and also for more granular testing of module's smaller units, like providers and middlewares.",source:"@site/docs/essentials/testing.md",sourceDirName:"essentials",slug:"/essentials/testing",permalink:"/docs/essentials/testing",editUrl:"https://github.com/Urigo/graphql-modules/edit/master/website/docs/essentials/testing.md",version:"current",sidebar_label:"Testing",frontMatter:{id:"testing",title:"Testing",sidebar_label:"Testing"},sidebar:"docs",previous:{title:"Type-Safety",permalink:"/docs/essentials/type-safety"},next:{title:"Dependency Injection",permalink:"/docs/di/introduction"}},d=[{value:"Testing application",id:"testing-application",children:[{value:"Replacing a module",id:"replacing-a-module",children:[]},{value:"Overwriting application providers",id:"overwriting-application-providers",children:[]}]},{value:"Testing modules",id:"testing-modules",children:[{value:"Turning type extensions into definitions",id:"turning-type-extensions-into-definitions",children:[]},{value:"Extending module&#39;s schema",id:"extending-modules-schema",children:[]},{value:"Inherit typeDefs from other modules",id:"inherit-typedefs-from-other-modules",children:[]},{value:"Importing other modules",id:"importing-other-modules",children:[]},{value:"Providers and Middlewares",id:"providers-and-middlewares",children:[]},{value:"Executing operations",id:"executing-operations",children:[]}]},{value:"Testing providers",id:"testing-providers",children:[{value:"testInjector",id:"testinjector",children:[]},{value:"readProviderOptions",id:"readprovideroptions",children:[]}]},{value:"Testing middlewares",id:"testing-middlewares",children:[]}],u={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"GraphQL Modules provides a set of utilities for testing your modules and also for more granular testing of module's smaller units, like providers and middlewares."),(0,a.kt)("p",null,"To access the testing utilities, import ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit")," object from ",(0,a.kt)("inlineCode",{parentName:"p"},"graphql-modules")," package:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { testkit } from 'graphql-modules';\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit")," object and its API will grow over time, we expect to implement more and more useful features in upcoming releases."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"GraphQL Modules depend on ",(0,a.kt)("strong",{parentName:"p"},"Reflect API")," for reflection and for defining dependencies between DI parts, please import ",(0,a.kt)("inlineCode",{parentName:"p"},"reflect-metadata")," in every test file or setup your testing framework to import it somewhere globally.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"The ",(0,a.kt)("a",{parentName:"p",href:"https://jestjs.io/"},"Jest framework")," is used in all example but its API is very similar to other testing frameworks.")),(0,a.kt)("h2",{id:"testing-application"},"Testing application"),(0,a.kt)("p",null,"When it comes to integration testing of an Application, the best practice is to avoid any significant modifications. That's why in our Test Kit you will find ",(0,a.kt)("inlineCode",{parentName:"p"},"mockApplication(app)")," function that accepts the original Application and lets you modify the Modules and application-level providers."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.mockApplication()")," resolves a ",(0,a.kt)("inlineCode",{parentName:"p"},"MockedApplication")," object that extends your original ",(0,a.kt)("inlineCode",{parentName:"p"},"Application")," with few useful methods."),(0,a.kt)("h3",{id:"replacing-a-module"},"Replacing a module"),(0,a.kt)("p",null,"One of those methods is ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceModule()"),". In combination with ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.mockModule()"),", it allows you to modify a module and overwrite its providers."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { application } from './application';\nimport { myModule, ENVIRONMENT } from './my-module';\n\ntest('ing', () => {\n  const app = testkit.mockApplication(application).replaceModule(\n    testkit.mockModule(myModule, {\n      providers: [\n        {\n          provide: ENVIRONMENT,\n          useValue: 'testing',\n        },\n      ],\n    })\n  );\n\n  expect(app.schema.getQueryType()).toBeDefined();\n});\n")),(0,a.kt)("p",null,"In the example above we modified the original application by setting testing ",(0,a.kt)("inlineCode",{parentName:"p"},"ENVIRONMENT")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"myModule"),". We used ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.mockApplication"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceModule")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.mockModule")," together."),(0,a.kt)("h3",{id:"overwriting-application-providers"},"Overwriting application providers"),(0,a.kt)("p",null,"Now let's talk about ",(0,a.kt)("inlineCode",{parentName:"p"},"addProviders()")," function. It allows you to overwrite application-level providers."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"In GraphQL Modules, always the last provider wins. What does it mean? When you pass a list of providers and two of them try to provide the same token, only the last one counts.\nWith this on mind, it's easy to overwrite providers, just put it at the end of the list. This is exactly how ",(0,a.kt)("inlineCode",{parentName:"p"},"addProviders()")," works.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { application, ENVIRONMENT } from './application';\n\ntest('ing', () => {\n  const app = testkit.mockApplication(application).addProviders([\n    {\n      provide: ENVIRONMENT,\n      useValue: 'testing',\n    },\n  ]);\n\n  expect(app.schema.getQueryType()).toBeDefined();\n});\n")),(0,a.kt)("p",null,"In the example above we modified the original application by setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"ENVIRONMENT")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"testing"),". We used ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.mockApplication")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"addProviders"),"."),(0,a.kt)("h2",{id:"testing-modules"},"Testing modules"),(0,a.kt)("p",null,"In general, the idea behind testing a module is to create an application out of it. Instead of using ",(0,a.kt)("inlineCode",{parentName:"p"},"createApplication()"),", our Test Kit provides a ",(0,a.kt)("inlineCode",{parentName:"p"},"testModule()")," function. It calls ",(0,a.kt)("inlineCode",{parentName:"p"},"createApplication")," under the hood but comes with a set of helpful options."),(0,a.kt)("p",null,"The easiest way to test a module would be to write the following code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { myModule } from './my-module';\n\ntest('ing', () => {\n  const app = testkit.testModule(myModule);\n\n  expect(app.schema.getQueryType()).toBeDefined();\n});\n")),(0,a.kt)("p",null,"Probaly none of your modules will work with ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule")," out of the box. That's because the module and especially its type definitions depend on types from another module or Dependency Injection is incomplete."),(0,a.kt)("h3",{id:"turning-type-extensions-into-definitions"},"Turning type extensions into definitions"),(0,a.kt)("p",null,"In case your module extends the ",(0,a.kt)("inlineCode",{parentName:"p"},"Query")," type or other types and does not depend on other modules, transforming ",(0,a.kt)("inlineCode",{parentName:"p"},"extend type X")," into ",(0,a.kt)("inlineCode",{parentName:"p"},"type X")," should do the work."),(0,a.kt)("p",null,"To turn on the transformation please enable ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceExtensions")," flag in options - ",(0,a.kt)("inlineCode",{parentName:"p"},"testModule(mod, options)"),"."),(0,a.kt)(i.Z,{defaultValue:"test",values:[{label:"my-module.spec.ts",value:"test"},{label:"my-module.ts",value:"module"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"test",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { myModule } from './my-module';\n\ntest('ing', () => {\n  const app = testkit.testModule(myModule, {\n    replaceExtensions: true,\n  });\n\n  expect(app.schema.getQueryType()).toBeDefined();\n});\n"))),(0,a.kt)(l.Z,{value:"module",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createModule, gql } from 'graphql-modules';\n\nexport const myModule = createModule({\n  id: 'my-module',\n  typeDefs: gql`\n    extend type Query {\n      me: User\n    }\n\n    type User {\n      id: ID\n    }\n  `,\n});\n")))),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceExtensions")," flag turned your module's schema into a valid and executable schema."),(0,a.kt)("h3",{id:"extending-modules-schema"},"Extending module's schema"),(0,a.kt)("p",null,"In case your module extends the ",(0,a.kt)("inlineCode",{parentName:"p"},"Query")," type or other types and using ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceExtensions")," flag won't work, ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule")," allows to define additional ",(0,a.kt)("inlineCode",{parentName:"p"},"typeDefs")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"resolvers"),"."),(0,a.kt)(i.Z,{defaultValue:"test",values:[{label:"my-module.spec.ts",value:"test"},{label:"my-module.ts",value:"module"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"test",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit, gql } from 'graphql-modules';\nimport { myModule } from './my-module';\n\ntest('ing', () => {\n  const app = testkit.testModule(myModule, {\n    typeDefs: gql`\n      type User {\n        name: String\n      }\n    `,\n    resolvers: {\n      Query: {\n        me() {\n          return {\n            name: 'Bob',\n          };\n        },\n      },\n    },\n    replaceExtensions: true,\n  });\n\n  expect(app.schema.getQueryType()).toBeDefined();\n});\n"))),(0,a.kt)(l.Z,{value:"module",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createModule, gql } from 'graphql-modules';\n\nexport const myModule = createModule({\n  id: 'my-module',\n  typeDefs: gql`\n    extend type Query {\n      me: User\n    }\n  `,\n});\n")))),(0,a.kt)("p",null,"In the example above, the ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceExtensions")," transformed ",(0,a.kt)("inlineCode",{parentName:"p"},"extend type Query")," into ",(0,a.kt)("inlineCode",{parentName:"p"},"type Query")," and additional typeDefs and resolvers were provided. As you can see, these two approaches of extending the schema can be used together and simplified testing a lot."),(0,a.kt)("h3",{id:"inherit-typedefs-from-other-modules"},"Inherit typeDefs from other modules"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule")," allows to add type definitions from other modules using ",(0,a.kt)("inlineCode",{parentName:"p"},"inheritTypeDefs")," option. Thanks to tree-shaking performed by ",(0,a.kt)("inlineCode",{parentName:"p"},"inheritTypeDefs"),", your tested module includes only the relevant types."),(0,a.kt)(i.Z,{defaultValue:"test",values:[{label:"my-module.spec.ts",value:"test"},{label:"my-module.ts",value:"module"},{label:"other-module.ts",value:"other-module"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"test",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { myModule } from './my-module';\nimport { otherModule } from './other-module';\n\ntest('ing', () => {\n  const app = testkit.testModule(myModule, {\n    inheritTypeDefs: [otherModule],\n  });\n\n  expect(app.schema.getTypes().Message).not.toBeDefined();\n});\n"))),(0,a.kt)(l.Z,{value:"module",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createModule, gql } from 'graphql-modules';\n\nexport const myModule = createModule({\n  id: 'my-module',\n  typeDefs: gql`\n    type Query {\n      me: User\n    }\n  `,\n});\n"))),(0,a.kt)(l.Z,{value:"other-module",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createModule, gql } from 'graphql-modules';\n\nexport const otherModule = createModule({\n  id: 'other-module',\n  typeDefs: gql`\n    extend type Query {\n      messages: [Message]\n      users: [User]\n    }\n\n    type Message {\n      text: String\n    }\n\n    type User {\n      name: String\n    }\n  `,\n});\n")))),(0,a.kt)("p",null,"In the example above, the tested module inherits ",(0,a.kt)("inlineCode",{parentName:"p"},"User")," type from ",(0,a.kt)("inlineCode",{parentName:"p"},"other-module")," and thanks to tree-shaking the ",(0,a.kt)("inlineCode",{parentName:"p"},"Message")," type and ",(0,a.kt)("inlineCode",{parentName:"p"},"Query.messages")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Query.users")," are not in the schema."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"inheritTypeDefs")," is useful when you don't want to define types manually but rather use existing definitions."),(0,a.kt)("h3",{id:"importing-other-modules"},"Importing other modules"),(0,a.kt)("p",null,"There's a chance you may want to include other modules in the tested application."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule()")," let's you do it with ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," options."),(0,a.kt)("p",null,"It accepts an array of modules and has exactly the same effect as ",(0,a.kt)("inlineCode",{parentName:"p"},"createAppliction({ modules: [...] })"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { myModule } from './my-module';\nimport { otherModule } from './other-module';\n\ntest('ing', () => {\n  const app = testkit.testModule(myModule, {\n    modules: [otherModule],\n  });\n});\n")),(0,a.kt)("h3",{id:"providers-and-middlewares"},"Providers and Middlewares"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule()")," accepts ",(0,a.kt)("inlineCode",{parentName:"p"},"providers")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"middlewares"),". They both end up on application-level."),(0,a.kt)("p",null,"More on that in next two sections: ",(0,a.kt)("a",{parentName:"p",href:"#testing-providers"},"Testing Providers"),", ",(0,a.kt)("a",{parentName:"p",href:"#testing-middlewares"},"Testing Middlewares"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { myModule } from './my-module';\nimport { myMiddleware } from './my-middleware';\nimport { MyProvider } from './my-provider';\n\ntest('ing', () => {\n  const app = testkit.testModule(myModule, {\n    providers: [\n      {\n        provide: MyProvider,\n        useValue: {},\n      },\n    ],\n    middlewares: {\n      Query: {\n        '*': [myMiddleware],\n      },\n    },\n  });\n});\n")),(0,a.kt)("h3",{id:"executing-operations"},"Executing operations"),(0,a.kt)("p",null,"As explained earlier, testing a module means creating an application. There's a reason behind it."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule")," calls ",(0,a.kt)("inlineCode",{parentName:"p"},"createApplication")," internally, this way we keep exactly the same logic as your GraphQL API operates on."),(0,a.kt)("p",null,"We highly recommend to test the entire execution flow instead of focusing on individual pieces. That's why ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit")," ships with ",(0,a.kt)("inlineCode",{parentName:"p"},"execute")," helper."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit, gql } from 'graphql-modules';\nimport { myModule, UsersProvider } from './my-module';\n\ntest('ing', async () => {\n  const app = testkit.testModule(myModule, {\n    providers: [\n      {\n        provide: UsersProvider,\n        useValue: {\n          getCurrentUser() {\n            return {\n              name: 'Bob',\n            };\n          },\n        },\n      },\n    ],\n  });\n\n  const result = testkit.execute(app, {\n    document: gql`\n      {\n        me {\n          name\n        }\n      }\n    `,\n  });\n\n  expect(result.data.me.name).toEqual('Bob');\n});\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.execute")," doesn't help a lot but without it, you would have to call ",(0,a.kt)("inlineCode",{parentName:"p"},"app.createExecution"),", extract ",(0,a.kt)("inlineCode",{parentName:"p"},"app.schema")," and put it all together to execute an operation. Two lines of code you don't need to worry about!"),(0,a.kt)("h2",{id:"testing-providers"},"Testing providers"),(0,a.kt)("p",null,"There are two ways of testing providers, using ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testInjector"),". The former was already covered in one of the previous sections."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testInjector")," let's you play with providers purely on Injector level or in other words in total isolation. There are no modules or application which means no hierarchy and layering."),(0,a.kt)("h3",{id:"testinjector"},"testInjector"),(0,a.kt)(i.Z,{defaultValue:"test",values:[{label:"logger.spec.ts",value:"test"},{label:"logger.ts",value:"provider"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"test",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit } from 'graphql-modules';\nimport { Logger, LoggerTransport } from './logger';\n\ntest('ing', () => {\n  const transportLogSpy = jest.fn();\n  const injector = testkit.testInjector([\n    Logger,\n    {\n      provide: LoggerTransport,\n      useValue: {\n        log: transportLogSpy,\n      },\n    },\n  ]);\n\n  const logger = injector.get(Logger);\n\n  logger.log('hello');\n\n  expect(transportLogSpy).toHaveBeenCalledWith('hello');\n});\n"))),(0,a.kt)(l.Z,{value:"provider",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Injectable, Inject, InjectionToken, Scope } from 'graphql-modules';\n\nexport const LoggerTransport = new InjectionToken<ILoggerTransport>(\n  'logger-transport'\n);\n\nexport interface ILoggerTransport {\n  log(msg: string): void;\n}\n\n@Injectable({\n  scope: Scope.Singleton,\n})\nexport class Logger {\n  constructor(@Inject(LoggerTransport) private transport: ILoggerTransport) {}\n\n  log(msg: string) {\n    this.transport.log(msg);\n  }\n}\n")))),(0,a.kt)("p",null,"In the example above, thanks to the abstraction, we were able to provide a custom transport layer for our Logger.\nThis way we know that every call of ",(0,a.kt)("inlineCode",{parentName:"p"},"Logger.log(msg)")," passes the ",(0,a.kt)("inlineCode",{parentName:"p"},"msg")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ILoggerTransport.log(msg)"),"."),(0,a.kt)("h3",{id:"readprovideroptions"},"readProviderOptions"),(0,a.kt)("p",null,"From the performance perspective, it's important to make sure all sinleton providers are in fact singletons and ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.readProviderOptions")," helps with that."),(0,a.kt)("p",null,"Let's use again the ",(0,a.kt)("inlineCode",{parentName:"p"},"Logger")," example. This time we want to check the scope of the provider."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit, Scope } from 'graphql-modules';\nimport { Logger } from './logger';\n\ntest('ing', () => {\n  const options = testkit.readProviderOptions(Logger);\n\n  expect(options.scope).toEqual(Scope.Singleton);\n});\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.readProviderOptions")," returns the ",(0,a.kt)("inlineCode",{parentName:"p"},"ProviderOptions")," object with ",(0,a.kt)("inlineCode",{parentName:"p"},"scope"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"global")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"executionContextIn")," properties."),(0,a.kt)("h2",{id:"testing-middlewares"},"Testing middlewares"),(0,a.kt)("p",null,"Testing a middleware requires a GraphQL Schema. Using ",(0,a.kt)("inlineCode",{parentName:"p"},"testkit.testModule")," fits perfectly in this scenario."),(0,a.kt)("p",null,"Depending on complexity of a middleware function, you may want to use or mock different pieces of GraphQL Modules. We tried to cover the most common scenario in the example below."),(0,a.kt)(i.Z,{defaultValue:"test",values:[{label:"my-module.spec.ts",value:"test"},{label:"my-module.ts",value:"module"},{label:"auth.ts",value:"auth"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"test",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\nimport { testkit, gql } from 'graphql-modules';\nimport { myModule } from './my-module';\n\ntest('ing', () => {\n  const app = testkit.testModule(myModule);\n\n  const result = await testkit.execute(app, {\n    document: gql`\n      {\n        me {\n          name\n        }\n      }\n    `,\n    contextValue: {\n      isLoggedIn: false,\n    },\n  });\n\n  expect(result.errors).toHaveLength(1);\n  expect(result.data.me).toBeNull();\n});\n"))),(0,a.kt)(l.Z,{value:"module",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createModule, gql } from 'graphql-modules';\nimport { AuthProvider, authMiddleware } from './auth';\n\nexport const myModule = createModule({\n  id: 'my-module',\n  typeDefs: gql`\n    type Query {\n      me: User\n    }\n\n    type User {\n      name: String\n    }\n  `,\n  resolvers: {\n    Query: {\n      me() {\n        return {\n          name: 'Bob',\n        };\n      },\n    },\n  },\n  providers: [AuthProvider],\n  middleware: {\n    Query: {\n      me: [authMiddleware],\n    },\n  },\n});\n"))),(0,a.kt)(l.Z,{value:"auth",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Injectable, Inject, Scope, CONTEXT } from 'graphql-modules';\n\n@Injectable({\n  scope: Scope.Operation,\n})\nexport class AuthProvider {\n  constructor(@Inject(CONTEXT) private context: { isLoggedIn: boolean }) {}\n\n  isLoggedIn() {\n    return this.context.isLoggedIn === true;\n  }\n}\n\nasync function authMiddleware({ context }, next) {\n  if (!context.injector.get(AuthProvider).isLoggedIn()) {\n    throw new Error('Not logged in');\n  }\n\n  return next();\n}\n")))),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"authMiddleware")," prevents private data from leaking out by using ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthProvider.isLoggedIn()")," method. The ",(0,a.kt)("inlineCode",{parentName:"p"},"isLoggedIn")," flag is provided via context of the GraphQL operation. This is done for simplicity of the example but usually you would validate a visitor's session or something similar."),(0,a.kt)("p",null,"Because in ",(0,a.kt)("inlineCode",{parentName:"p"},"contextValue")," we marked the incoming request as not authenticated (",(0,a.kt)("inlineCode",{parentName:"p"},"{ isLoggedIn: false }"),"), we expect the GraphQL Operation to fail before resolving the original ",(0,a.kt)("inlineCode",{parentName:"p"},"Query.me")," field."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"If you wish to see more testing utilities or have some ideas, reach out to us.")))}m.isMDXComponent=!0},6010:function(e,t,n){"use strict";function o(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=o(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function r(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=o(e))&&(r&&(r+=" "),r+=t);return r}n.d(t,{Z:function(){return r}})}}]);